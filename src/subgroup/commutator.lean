import subgroup.cyclic

/- In this file we will define the commutator and some APIs for it. -/

namespace mygroup

open_locale classical

open mygroup.subgroup mygroup.quotient group_hom function set

variables {G : Type} [group G]

/-- The commutator of two elements `a`, `b` of a group `G` is `a * b * a⁻¹ * b⁻¹`-/
def commutator (a b : G) := a * b * a ⁻¹ * b⁻¹

@[simp] lemma commutator_def {a b : G} : commutator a b = a * b * a⁻¹ * b⁻¹ := rfl

-- To show that the subgroup generated by the set of commutators is normal, we 
-- first need a more general lemma for showing normal'ness' of closures, i.e. 
-- the fact that the closure is normal if the set is closed under conjugation

-- We will use the induction principle on closure of subgroups

/-- The closure of an invariant set is also invariant under conjugation -/
lemma closure_normal {s : set G} (hs : ∀ t ∈ s, ∀ g : G, g * t * g⁻¹ ∈ s) : 
  ∀ t ∈ closure s, ∀ g : G, g * t * g⁻¹ ∈ closure s := 
begin
  intros t ht g,
  apply closure_induction ht,
    exact λ x hx, le_closure _ (hs x hx g),
    simp [one_mem],
    intros x y hx hy,
    conv_lhs 
      { congr, congr, skip, congr, 
        rw [show x = x * g⁻¹ * g, by simp [group.mul_assoc]] },
    rw [show g * (x * g⁻¹ * g * y) * g⁻¹ = g * x * g⁻¹ * (g * y * g⁻¹), 
        by simp [group.mul_assoc]],
    refine mul_mem _ hx hy,
    intros x hx, refine (inv_mem_iff _).1 _,
    simpa [← group.mul_assoc],
end

/-- The commutator is the normal subgroup generated by the set of commutators -/
def commutator_subgroup (G : Type) [group G] : normal G := 
{ conj_mem' := 
  begin
    intros n hn g,
    refine closure_normal _ _ hn _,
    rintro t ⟨a, b, rfl⟩ g,
    rw [commutator_def, show g * (a * b * a⁻¹ * b⁻¹) * g⁻¹ = 
          g * a * g⁻¹ * (g * b * g⁻¹) * (g * a * g⁻¹)⁻¹ * (g * b * g⁻¹)⁻¹, 
          by simp [group.mul_assoc]],
    exact ⟨g * a * g⁻¹, (g * b * g⁻¹), rfl⟩,
  end .. closure { c | ∃ a b : G, c = commutator a b } }

/-- A group `G` the abelian if and only if the cummutator subgroup is `{1}`-/
lemma comm_group_iff : (commutator_subgroup G : set G) = {1} ↔ 
  ∀ a b : G, a * b = b * a :=
begin
  split, intros h a b,
    { change (closure { c | ∃ a b : G, c = commutator a b } : set G) = _ at h,
      have : {c : G | ∃ (a b : G), c = commutator a b} = {1},
        apply subset.antisymm, rw ← h, exact le_closure _,
        rw singleton_subset_iff, exact ⟨a, a⁻¹, by simp⟩,
      rw eq_singleton_iff_unique_mem at this,
      rw [← group.mul_right_cancel_iff (a⁻¹ * b⁻¹),
          (this.right (a * b * (a⁻¹ * b⁻¹)) 
          ⟨a, b, by simp [group.mul_assoc]⟩).symm],
      simp [group.mul_assoc] },
    { intros h, apply subset.antisymm,
        { change closure { c | ∃ a b : G, c = commutator a b } ≤ trivial,
          rw closure_le, rintro _ ⟨a, b, rfl⟩, rw [commutator_def, h a b, mem_coe'], 
          simp [group.mul_assoc, subgroup.trivial, ← mem_coe] },
        { intros x hx, rw mem_singleton_iff at hx, subst hx, exact one_mem _ } }
end

end mygroup