import subgroup.cyclic

/- In this file we will define the commutator and some APIs for it. -/

namespace mygroup

open_locale classical

open mygroup.subgroup mygroup.quotient group_hom function set

variables {G : Type} [group G]

/-- The commutator of two elements `a`, `b` of a group `G` is `a * b * a⁻¹ * b⁻¹`-/
def commutator (a b : G) := a * b * a ⁻¹ * b⁻¹

@[simp] lemma commutator_def {a b : G} : commutator a b = a * b * a⁻¹ * b⁻¹ := rfl

-- To show that the subgroup generated by the set of commutators is normal, we 
-- first need a more general lemma for showing normal'ness' of closures, i.e. 
-- the fact that the closure is normal if the set is closed under conjugation

-- We will use the induction principle on closure of subgroups

/-- The closure of an invariant set is also invariant under conjugation -/
lemma closure_normal {s : set G} (hs : ∀ t ∈ s, ∀ g : G, g * t * g⁻¹ ∈ s) : 
  ∀ t ∈ closure s, ∀ g : G, g * t * g⁻¹ ∈ closure s := 
begin
  intros t ht g,
  apply closure_induction ht,
    exact λ x hx, le_closure _ (hs x hx g),
    simp [one_mem],
    intros x y hx hy,
    conv_lhs 
      { congr, congr, skip, congr, 
        rw [show x = x * g⁻¹ * g, by simp [group.mul_assoc]] },
    rw [show g * (x * g⁻¹ * g * y) * g⁻¹ = g * x * g⁻¹ * (g * y * g⁻¹), 
        by simp [group.mul_assoc]],
    refine mul_mem _ hx hy,
    intros x hx, refine (inv_mem_iff _).1 _,
    simpa [← group.mul_assoc],
end

/-- The commutator is the normal subgroup generated by the set of commutators -/
def commutator_subgroup (G : Type) [group G] : normal G := 
{ conj_mem' := 
  begin
    intros n hn g,
    refine closure_normal _ _ hn _,
    rintro t ⟨a, b, rfl⟩ g,
    rw [commutator_def, show g * (a * b * a⁻¹ * b⁻¹) * g⁻¹ = 
          g * a * g⁻¹ * (g * b * g⁻¹) * (g * a * g⁻¹)⁻¹ * (g * b * g⁻¹)⁻¹, 
          by simp [group.mul_assoc]],
    exact ⟨g * a * g⁻¹, (g * b * g⁻¹), rfl⟩,
  end .. closure { c | ∃ a b : G, c = commutator a b } }

end mygroup